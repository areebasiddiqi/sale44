import { PDFDocument, rgb, StandardFonts } from 'pdf-lib'

// Function to sanitize text for PDF generation
function sanitizeText(text: string): string {
  if (!text) return ''
  return text
    .replace(/✓/g, '+')
    .replace(/⚠/g, '!')
    .replace(/•/g, '-')
    .replace(/→/g, '->')
    .replace(/←/g, '<-')
    .replace(/↑/g, '^')
    .replace(/↓/g, 'v')
    .replace(/★/g, '*')
    .replace(/☆/g, '*')
    .replace(/◆/g, '*')
    .replace(/◇/g, '*')
    .replace(/■/g, '*')
    .replace(/□/g, '*')
    .replace(/▲/g, '^')
    .replace(/▼/g, 'v')
    .replace(/►/g, '>')
    .replace(/◄/g, '<')
    .replace(/[^\x00-\x7F]/g, '?') // Replace any remaining non-ASCII characters
}

export async function generateAuditReport(audit: any, auditResult?: any, watermarked: boolean = true): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create()
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica)
  const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold)
  const helveticaItalic = await pdfDoc.embedFont(StandardFonts.HelveticaOblique)
  
  // Use auditResult if provided, otherwise use audit
  const result = auditResult || audit
  
  // Colors
  const primaryColor = rgb(0.2, 0.4, 0.8) // Blue
  const textColor = rgb(0.2, 0.2, 0.2) // Dark gray
  const lightGray = rgb(0.9, 0.9, 0.9)
  const successColor = rgb(0.1, 0.7, 0.1) // Green
  const warningColor = rgb(0.9, 0.6, 0.1) // Orange
  const dangerColor = rgb(0.8, 0.2, 0.2) // Red
  
  // Page setup
  const pageWidth = 595.28 // A4 width in points
  const pageHeight = 841.89 // A4 height in points
  const margin = 50
  
  // Add first page
  let page = pdfDoc.addPage([pageWidth, pageHeight])
  let yPosition = pageHeight - margin
  
  // Helper function to add watermark
  const addWatermark = (currentPage: any) => {
    if (watermarked) {
      currentPage.drawText('GENERATED BY SALE44 FREE', {
        x: pageWidth / 2 - 100,
        y: pageHeight / 2,
        size: 40,
        font: helveticaBold,
        color: rgb(0.9, 0.9, 0.9),
        rotate: { type: 'degrees', angle: -45 },
      })
    }
  }
  
  // Helper function to check if we need a new page
  const checkNewPage = (requiredSpace: number) => {
    if (yPosition - requiredSpace < margin) {
      page = pdfDoc.addPage([pageWidth, pageHeight])
      yPosition = pageHeight - margin
    }
  }
  
  // Title
  page.drawText(sanitizeText('Business Audit Report'), {
    x: margin,
    y: yPosition,
    size: 24,
    font: helveticaBold,
    color: primaryColor,
  })
  yPosition -= 40
  
  // Company info
  const companyName = audit.name || audit.business_name || audit.url || 'N/A'
  page.drawText(sanitizeText(`Company: ${companyName}`), {
    x: margin,
    y: yPosition,
    size: 14,
    font: helveticaFont,
    color: textColor,
  })
  yPosition -= 20
  
  page.drawText(sanitizeText(`Generated: ${new Date().toLocaleDateString()}`), {
    x: margin,
    y: yPosition,
    size: 12,
    font: helveticaFont,
    color: textColor,
  })
  yPosition -= 40
  
  
  // Overall Score
  checkNewPage(100)
  
  // Score background
  page.drawRectangle({
    x: margin,
    y: yPosition - 60,
    width: pageWidth - 2 * margin,
    height: 80,
    color: lightGray,
  })
  
  page.drawText('OVERALL AUDIT SCORE', {
    x: margin + 20,
    y: yPosition - 20,
  })
  
  // Score circle (simplified as text)
  const totalScore = result.totalScore || audit.total_score || 0
  const scoreColor = totalScore >= 80 ? successColor :
                    totalScore >= 60 ? primaryColor :
                    totalScore >= 40 ? warningColor : dangerColor

  page.drawText(sanitizeText(`${totalScore}/100`), {
    x: pageWidth - margin - 100,
    y: yPosition - 30,
    size: 32,
    font: helveticaBold,
    color: scoreColor,
  })

  const scoreLabel = totalScore >= 80 ? 'EXCELLENT' :
                    totalScore >= 60 ? 'GOOD' :
                    totalScore >= 40 ? 'FAIR' : 'POOR'
  
  page.drawText(scoreLabel, {
    x: pageWidth - margin - 100,
    y: yPosition - 50,
    size: 12,
    font: helveticaBold,
    color: scoreColor,
  })
  
  yPosition -= 100
  
  // Parameter Breakdown
  checkNewPage(50)
  page.drawText('PARAMETER BREAKDOWN', {
    x: margin,
    y: yPosition,
    size: 16,
    font: helveticaBold,
    color: primaryColor,
  })
  yPosition -= 30
  
  // Iterate through parameters
  Object.entries(result.parameters || {}).forEach(([key, param]: [string, any]) => {
    checkNewPage(150)
    
    // Parameter header
    page.drawText(sanitizeText(param.name), {
      x: margin,
      y: yPosition,
      size: 14,
      font: helveticaBold,
      color: textColor,
    })
    
    page.drawText(sanitizeText(`${param.score}/100`), {
      x: pageWidth - margin - 150,
      y: yPosition,
      size: 12,
      font: helveticaFont,
      color: textColor,
    })
    yPosition -= 25
    
    // Progress bar (simplified as rectangle)
    const barWidth = 200
    const barHeight = 8
    
    // Background bar
    page.drawRectangle({
      x: margin,
      y: yPosition - barHeight,
      width: barWidth,
      height: barHeight,
      color: lightGray,
    })
    
    // Progress bar
    const progressWidth = (param.score / 100) * barWidth
    const progressColor = param.score >= 80 ? successColor :
                         param.score >= 60 ? primaryColor :
                         param.score >= 40 ? warningColor : dangerColor
    
    page.drawRectangle({
      x: margin,
      y: yPosition - barHeight,
      width: progressWidth,
      height: barHeight,
      color: progressColor,
    })
    yPosition -= 25
    
    // Insights
    if (param.insights && param.insights.length > 0) {
      page.drawText('+ Strengths:', {
        x: margin,
        y: yPosition,
        size: 11,
        font: helveticaBold,
        color: successColor,
      })
      yPosition -= 15
      
      param.insights.forEach((insight: string) => {
        checkNewPage(20)
        const wrappedText = wrapText(sanitizeText(insight), 80)
        wrappedText.forEach((line: string) => {
          page.drawText(sanitizeText(`  - ${line}`), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 12
        })
      })
      yPosition -= 5
    }
    
    // Recommendations
    if (param.recommendations && param.recommendations.length > 0) {
      checkNewPage(20)
      page.drawText('! Recommendations:', {
        x: margin,
        y: yPosition,
        size: 11,
        font: helveticaBold,
        color: warningColor,
      })
      yPosition -= 15
      
      param.recommendations.forEach((rec: string) => {
        checkNewPage(20)
        const wrappedText = wrapText(sanitizeText(rec), 80)
        wrappedText.forEach((line: string) => {
          page.drawText(sanitizeText(`  - ${line}`), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 12
        })
      })
    }
    
    yPosition -= 20
  })
  
  // Executive Summary (if available)
  if (result.executiveSummary) {
    checkNewPage(100)
    page.drawText('EXECUTIVE SUMMARY', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30
    
    const wrappedExecutiveSummary = wrapText(sanitizeText(result.executiveSummary), 90)
    wrappedExecutiveSummary.forEach((line: string) => {
      checkNewPage(15)
      page.drawText(sanitizeText(line), {
        x: margin,
        y: yPosition,
        size: 11,
        font: helveticaFont,
        color: textColor,
      })
      yPosition -= 15
    })
    yPosition -= 20
  }

  // Key Findings (if available)
  if (result.keyFindings && result.keyFindings.length > 0) {
    checkNewPage(100)
    page.drawText('KEY FINDINGS', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30
    
    result.keyFindings.slice(0, 6).forEach((finding: string, index: number) => {
      checkNewPage(30)
      page.drawText(`${index + 1}.`, {
        x: margin,
        y: yPosition,
        size: 11,
        font: helveticaBold,
        color: textColor,
      })
      
      const wrappedFinding = wrapText(sanitizeText(finding), 85)
      wrappedFinding.forEach((line: string, lineIndex: number) => {
        checkNewPage(15)
        page.drawText(sanitizeText(line), {
          x: margin + (lineIndex === 0 ? 20 : 0),
          y: yPosition,
          size: 11,
          font: helveticaFont,
          color: textColor,
        })
        yPosition -= 15
      })
      yPosition -= 5
    })
    yPosition -= 15
  }

  // Priority Recommendations (if available)
  if (result.priorityRecommendations && result.priorityRecommendations.length > 0) {
    checkNewPage(100)
    page.drawText('PRIORITY RECOMMENDATIONS', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30
    
    result.priorityRecommendations.slice(0, 5).forEach((recommendation: string, index: number) => {
      checkNewPage(30)
      page.drawText(`${index + 1}.`, {
        x: margin,
        y: yPosition,
        size: 11,
        font: helveticaBold,
        color: warningColor,
      })
      
      const wrappedRecommendation = wrapText(sanitizeText(recommendation), 85)
      wrappedRecommendation.forEach((line: string, lineIndex: number) => {
        checkNewPage(15)
        page.drawText(sanitizeText(line), {
          x: margin + (lineIndex === 0 ? 20 : 0),
          y: yPosition,
          size: 11,
          font: helveticaFont,
          color: textColor,
        })
        yPosition -= 15
      })
      yPosition -= 5
    })
    yPosition -= 15
  }

  // AI Readiness Overview (if available)
  if (result.aiReadinessOverview) {
    checkNewPage(150)
    page.drawText('AI READINESS OVERVIEW', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30

    // Category Analysis
    if (result.aiReadinessOverview.categoryAnalysis) {
      checkNewPage(50)
      page.drawText('Category Analysis:', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: textColor,
      })
      yPosition -= 20
      
      const wrappedCategoryAnalysis = wrapText(sanitizeText(result.aiReadinessOverview.categoryAnalysis), 90)
      wrappedCategoryAnalysis.forEach((line: string) => {
        checkNewPage(15)
        page.drawText(sanitizeText(line), {
          x: margin + 10,
          y: yPosition,
          size: 11,
          font: helveticaFont,
          color: textColor,
        })
        yPosition -= 15
      })
      yPosition -= 10
    }

    // Key Strengths
    if (result.aiReadinessOverview.keyStrengths && result.aiReadinessOverview.keyStrengths.length > 0) {
      checkNewPage(50)
      page.drawText('Key Strengths:', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: successColor,
      })
      yPosition -= 20
      
      result.aiReadinessOverview.keyStrengths.forEach((strength: string) => {
        checkNewPage(20)
        const wrappedStrength = wrapText(sanitizeText(`• ${strength}`), 85)
        wrappedStrength.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 10
    }

    // Critical Gaps
    if (result.aiReadinessOverview.criticalGaps && result.aiReadinessOverview.criticalGaps.length > 0) {
      checkNewPage(50)
      page.drawText('Critical Gaps:', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: dangerColor,
      })
      yPosition -= 20
      
      result.aiReadinessOverview.criticalGaps.forEach((gap: string) => {
        checkNewPage(20)
        const wrappedGap = wrapText(sanitizeText(`• ${gap}`), 85)
        wrappedGap.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 15
    }
  }

  // Action Plan (if available)
  if (result.actionPlan) {
    checkNewPage(150)
    page.drawText('ACTION PLAN', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30

    // Immediate Actions
    if (result.actionPlan.immediate && result.actionPlan.immediate.length > 0) {
      checkNewPage(50)
      page.drawText('Immediate Actions (1-2 weeks):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: dangerColor,
      })
      yPosition -= 20
      
      result.actionPlan.immediate.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 10
    }

    // Short-term Actions
    if (result.actionPlan.shortTerm && result.actionPlan.shortTerm.length > 0) {
      checkNewPage(50)
      page.drawText('Short-term Actions (1-3 months):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: warningColor,
      })
      yPosition -= 20
      
      result.actionPlan.shortTerm.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 10
    }

    // Long-term Actions
    if (result.actionPlan.longTerm && result.actionPlan.longTerm.length > 0) {
      checkNewPage(50)
      page.drawText('Long-term Actions (6+ months):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: successColor,
      })
      yPosition -= 20
      
      result.actionPlan.longTerm.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 15
    }
  }

  // Strategic Action Plan (if available)
  if (result.strategicActionPlan) {
    checkNewPage(150)
    page.drawText('STRATEGIC ACTION PLAN', {
      x: margin,
      y: yPosition,
      size: 16,
      font: helveticaBold,
      color: primaryColor,
    })
    yPosition -= 30

    // Immediate Actions (1-3 months)
    if (result.strategicActionPlan.immediateActions && result.strategicActionPlan.immediateActions.length > 0) {
      checkNewPage(50)
      page.drawText('Immediate Actions (1-3 months):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: dangerColor,
      })
      yPosition -= 20
      
      result.strategicActionPlan.immediateActions.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 10
    }

    // Short-term Strategy (3-6 months)
    if (result.strategicActionPlan.shortTermStrategy && result.strategicActionPlan.shortTermStrategy.length > 0) {
      checkNewPage(50)
      page.drawText('Short-term Strategy (3-6 months):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: warningColor,
      })
      yPosition -= 20
      
      result.strategicActionPlan.shortTermStrategy.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 10
    }

    // Long-term Roadmap (6-12 months)
    if (result.strategicActionPlan.longTermRoadmap && result.strategicActionPlan.longTermRoadmap.length > 0) {
      checkNewPage(50)
      page.drawText('Long-term Roadmap (6-12 months):', {
        x: margin,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: successColor,
      })
      yPosition -= 20
      
      result.strategicActionPlan.longTermRoadmap.forEach((action: string) => {
        checkNewPage(20)
        const wrappedAction = wrapText(sanitizeText(`• ${action}`), 85)
        wrappedAction.forEach((line: string) => {
          checkNewPage(15)
          page.drawText(sanitizeText(line), {
            x: margin + 10,
            y: yPosition,
            size: 10,
            font: helveticaFont,
            color: textColor,
          })
          yPosition -= 15
        })
      })
      yPosition -= 15
    }
  }

  // Summary and Next Steps
  checkNewPage(100)
  page.drawText('SUMMARY & NEXT STEPS', {
    x: margin,
    y: yPosition,
    size: 16,
    font: helveticaBold,
    color: primaryColor,
  })
  yPosition -= 30
  
  const summaryText = `Based on our comprehensive analysis, your business scored ${totalScore}/100. This indicates ${scoreLabel.toLowerCase()} performance across the key business parameters we evaluated.`
  
  const wrappedSummary = wrapText(sanitizeText(summaryText), 90)
  wrappedSummary.forEach((line: string) => {
    checkNewPage(15)
    page.drawText(sanitizeText(line), {
      x: margin,
      y: yPosition,
      size: 11,
      font: helveticaFont,
      color: textColor,
    })
    yPosition -= 15
  })
  
  yPosition -= 20
  
  // Next steps
  const nextSteps = [
    'Focus on the lowest-scoring parameters for maximum impact',
    'Implement the specific recommendations provided',
    'Generate targeted leads based on your audit insights',
    'Re-audit in 3-6 months to track improvements'
  ]
  
  page.drawText('Recommended Next Steps:', {
    x: margin,
    y: yPosition,
    size: 12,
    font: helveticaBold,
    color: textColor,
  })
  yPosition -= 20
  
  nextSteps.forEach((step) => {
    checkNewPage(15)
    page.drawText(sanitizeText(`- ${step}`), {
      x: margin + 10,
      y: yPosition,
      size: 11,
      font: helveticaFont,
      color: textColor,
    })
    yPosition -= 15
  })
  
  // Footer
  checkNewPage(60)
  yPosition = margin + 30
  
  page.drawText('Generated by Sale44 - Autonomous Business Audit & Lead Generation', {
    x: margin,
    y: yPosition,
    size: 10,
    font: helveticaFont,
    color: rgb(0.6, 0.6, 0.6),
  })
  
  page.drawText('Visit sale44.com for more insights and lead generation', {
    x: margin,
    y: yPosition - 15,
    size: 10,
    font: helveticaFont,
    color: rgb(0.6, 0.6, 0.6),
  })
  
  // Add watermark to last page
  addWatermark(page)
  
  // Serialize the PDF
  const pdfBytes = await pdfDoc.save()
  return pdfBytes
}

// Helper function to wrap text
function wrapText(text: string, maxLength: number): string[] {
  const words = text.split(' ')
  const lines: string[] = []
  let currentLine = ''
  
  words.forEach((word) => {
    if ((currentLine + word).length <= maxLength) {
      currentLine += (currentLine ? ' ' : '') + word
    } else {
      if (currentLine) lines.push(currentLine)
      currentLine = word
    }
  })
  
  if (currentLine) lines.push(currentLine)
  return lines
}
